#!/bin/bash
#
# Generate Sysdump
# creates a snapshot of system state for debugging later.
#

set -u

ERROR_TAR_FAILED=5
ERROR_PROCFS_SAVE_FAILED=6
ERROR_INVALID_ARGUMENT=10

TAR=tar
MKDIR=mkdir
RM=rm
LN=ln
GZIP=gzip
CP=cp
MV=mv
GREP=grep
TOUCH=touch
V=
ALLOW_PROCESS_STOP=
NOOP=false
DO_COMPRESS=true
CMD_PREFIX=
SINCE_DATE="@0" # default is set to January 1, 1970 at 00:00:00 GMT
REFERENCE_FILE=/tmp/reference
TECHSUPPORT_TIME_INFO=`mktemp "/tmp/techsupport_time_info.XXXXXXXXXX"`
BASE=sonic_dump_`hostname`_`date +%Y%m%d_%H%M%S`
DUMPDIR=/var/dump
TARDIR=$DUMPDIR/$BASE
TARFILE=$DUMPDIR/$BASE.tar
LOGDIR=$DUMPDIR/$BASE/dump
PLUGINS_DIR=/usr/local/bin/debug-dump
NUM_ASICS=1
HOME=${HOME:-/root}
USER=${USER:-root}
TIMEOUT_MIN="5"
SKIP_BCMCMD=0

handle_signal()
{
    echo "Generate Dump received interrupt" >&2
    $RM $V -rf $TARDIR
    exit 1
}
trap 'handle_signal' SIGINT

save_bcmcmd() {
    local start_t=$(date +%s%3N)
    local end_t=0
    local cmd="$1"
    local filename=$2
    local filepath="${LOGDIR}/$filename"
    local do_gzip=${3:-false}
    local tarpath="${BASE}/dump/$filename"
    local timeout_cmd="timeout --foreground ${TIMEOUT_MIN}m"
    [ ! -d $LOGDIR ] && $MKDIR $V -p $LOGDIR

    if [ $SKIP_BCMCMD -eq 1 ]; then
        echo "Skip $cmd"
        return 0
    fi
    # eval required here to re-evaluate the $cmd properly at runtime
    # This is required if $cmd has quoted strings that should be bunched
    # as one argument, e.g. vtysh -c "COMMAND HERE" needs to have
    # "COMMAND HERE" bunched together as 1 arg to vtysh -c
    if $NOOP; then
        echo "${timeout_cmd} $cmd &> '${filepath}'"
    else
        eval "${timeout_cmd} $cmd" &> "${filepath}"
        ret=$?
        if [ $ret -ne 0 ]; then
            if [ $ret -eq 124 ]; then
                echo "Command: $cmd timedout after ${TIMEOUT_MIN} minutes."
            else
                grep "polling socket timeout: Success" ${filepath} &>/dev/null
                if [ $? -eq 0 ]; then
                    echo "bcmcmd command timeout. Setting SKIP_BCMCMD to true ..."
                    SKIP_BCMCMD=1
                fi
            fi
        fi
    fi
    if $do_gzip; then
        gzip ${filepath} 2>/dev/null
        tarpath="${tarpath}.gz"
        filepath="${filepath}.gz"
    fi
    ($TAR $V -rhf $TARFILE -C $DUMPDIR "$tarpath" \
        || abort "${ERROR_TAR_FAILED}" "tar append operation failed. Aborting to prevent data loss.") \
        && $RM $V -rf "$filepath"
    end_t=$(date +%s%3N)
    echo "[ save_bcmcmd:$cmd ] : $(($end_t-$start_t)) msec" >> $TECHSUPPORT_TIME_INFO
}

###############################################################################
# Runs a given bcmcmd command in all namesapces in case of multi ASIC platform
# Globals:
#  NUM_ASICS
# Arguments:
#  cmd: The command to run. Make sure that arguments with spaces have quotes
#  filename: the filename to save the output as in $BASE/dump
#  do_gzip: (OPTIONAL) true or false. Should the output be gzipped
# Returns:
#  None
###############################################################################
save_bcmcmd_all_ns() {
    local do_gzip=${3:-false}

    if [[ ( "$NUM_ASICS" > 1 ) ]]; then
        for (( i=0; i<$NUM_ASICS; i++ ))
        do
            local cmd="bcmcmd -n $i $1"
            local file="$2.$i"
            save_bcmcmd "$cmd" "$file" "$do_gzip"
        done
    else
        local cmd="bcmcmd $1"
        save_bcmcmd "$cmd" "$2" "$do_gzip"
    fi
}

###############################################################################
# Runs a comamnd and saves its output to the incrementally built tar.
# Command gets timedout if it runs for more than TIMEOUT_MIN minutes.
# Globals:
#  LOGDIR
#  BASE
#  MKDIR
#  TAR
#  TARFILE
#  DUMPDIR
#  V
#  RM
#  NOOP
# Arguments:
#  cmd: The command to run. Make sure that arguments with spaces have quotes
#  filename: the filename to save the output as in $BASE/dump
#  do_gzip: (OPTIONAL) true or false. Should the output be gzipped
#  save_stderr: (OPTIONAL) true or false. Should the stderr output be saved
# Returns:
#  None
###############################################################################
save_cmd() {
    local start_t=$(date +%s%3N)
    local end_t=0
    local cmd="$1"
    local filename=$2
    local filepath="${LOGDIR}/$filename"
    local do_gzip=${3:-false}
    local save_stderr=${4:-true}
    local tarpath="${BASE}/dump/$filename"
    local timeout_cmd="timeout --foreground ${TIMEOUT_MIN}m"
    local redirect="&>"
    [ ! -d $LOGDIR ] && $MKDIR $V -p $LOGDIR

    if ! $save_stderr
    then
        redirect=">"
    fi

    # eval required here to re-evaluate the $cmd properly at runtime
    # This is required if $cmd has quoted strings that should be bunched
    # as one argument, e.g. vtysh -c "COMMAND HERE" needs to have
    # "COMMAND HERE" bunched together as 1 arg to vtysh -c
    if $do_gzip; then
        tarpath="${tarpath}.gz"
        filepath="${filepath}.gz"
        local cmds="$cmd 2>&1 | gzip -c > '${filepath}'"
        if $NOOP; then
            echo "${timeout_cmd} bash -c \"${cmds}\""
        else
            eval "${timeout_cmd} bash -c \"${cmds}\""
            if [ $? -ne 0 ]; then
                echo "Command: $cmds timedout after ${TIMEOUT_MIN} minutes."
            fi
        fi
    else
        if $NOOP; then
            echo "${timeout_cmd} $cmd $redirect '$filepath'"
        else
            eval "${timeout_cmd} $cmd" "$redirect" "$filepath"
            if [ $? -ne 0 ]; then
                echo "Command: $cmd timedout after ${TIMEOUT_MIN} minutes."
            fi
        fi
    fi
    ($TAR $V -rhf $TARFILE -C $DUMPDIR "$tarpath" \
        || abort "${ERROR_TAR_FAILED}" "tar append operation failed. Aborting to prevent data loss.") \
        && $RM $V -rf "$filepath"
    end_t=$(date +%s%3N)
    echo "[ save_cmd:$cmd ] : $(($end_t-$start_t)) msec" >> $TECHSUPPORT_TIME_INFO
}

###############################################################################
# Runs a given command in all namesapces in case of multi ASIC platform, in
# default (host) namespace in single ASIC platform
# Globals:
#  NUM_ASICS
# Arguments:
#  cmd: The command to run. Make sure that arguments with spaces have quotes
#  filename: the filename to save the output as in $BASE/dump
#  do_gzip: (OPTIONAL) true or false. Should the output be gzipped
# Returns:
#  None
###############################################################################
save_cmd_all_ns() {
    local do_zip=${3:-false}

    # host or default namespace
    save_cmd "$1" "$2" "$do_zip"

    if [[ ( "$NUM_ASICS" > 1 ) ]] ; then
      for (( i=0; i<$NUM_ASICS; i++ ))
      do
          local cmd="sonic-netns-exec asic$i $1"
          local file="$2.$i"
          save_cmd "$cmd" "$file" "$do_zip"
      done
    fi
}

###############################################################################
# Copies a given file from a specified docker to the given target location
# default (host) namespace in single ASIC platform
# Globals:
#  None
# Arguments:
#  docker: docker name
#  filename: the filename to copy
#  destination: destination filename
# Returns:
#  None
###############################################################################
copy_from_docker() {
    local start_t=$(date +%s%3N)
    local end_t=0
    local docker=$1
    local filename=$2
    local dstpath=$3
    local timeout_cmd="timeout --foreground ${TIMEOUT_MIN}m"

    local touch_cmd="sudo docker exec -i ${docker} touch ${filename}"
    local cp_cmd="sudo docker cp ${docker}:${filename} ${dstpath}"

    if $NOOP; then
        echo "${timeout_cmd} ${touch_cmd}"
        echo "${timeout_cmd} ${cp_cmd}"
    else
        eval "${timeout_cmd} ${touch_cmd}"
        if [ $? -ne 0 ]; then
            echo "Command: $touch_cmd timedout after ${TIMEOUT_MIN} minutes."
        fi
        eval "${timeout_cmd} ${cp_cmd}"
        if [ $? -ne 0 ]; then
            echo "Command: $cp_cmd timedout after ${TIMEOUT_MIN} minutes."
        fi
    fi
    end_t=$(date +%s%3N)
    echo "[ copy_from_docker:${docker}:${filename} ] : $(($end_t-$start_t)) msec" \
        >> $TECHSUPPORT_TIME_INFO
}

###############################################################################
# Copies a given file from a specified docker to the given target location
# default (host) namespace in single ASIC platform
# Globals:
#  NUM_ASICS
# Arguments:
#  docker: docker name
#  filename: the filename to copy
#  destination: destination filename
# Returns:
#  None
###############################################################################
copy_from_masic_docker() {
    local docker=$1
    local filename=$2
    local dstpath=$3

    if [[ ("$NUM_ASICS" > 1) ]]; then
        for (( i=0; i<$NUM_ASICS; i++ ))
        do
            copy_from_docker "$docker$i" "$filename" "$dstpath.$i"
        done
    else
        copy_from_docker "$docker" "$filename" "$dstpath"
    fi
}

###############################################################################
# Returns namespace option to be used with vtysh commmand, based on the ASIC ID.
# Returns empty string if no ASIC ID is provided
# Globals:
#  None
# Arguments:
#  asic_id: (OPTIONAL) ASIC ID
# Returns:
#  vtysh namespace option
###############################################################################
get_vtysh_namespace() {
    local asic_id=${1:-""}
    local ns=""
    if [[ ( $asic_id = "" ) ]] ; then
        ns=""
    else
        ns=" -n  ${asic_id}"
    fi
    echo "$ns"
}

###############################################################################
# Runs a vtysh command in all namesapces for a multi ASIC platform, and in
# default (host) namespace in single ASIC platforms. Saves its output to the
# incrementally built tar.
# Globals:
#  None
# Arguments:
#  cmd: the vtysh command to run. This should NOT include vtysh -c
#  filename: The filename to save the output as.
#  do_gzip: (OPTIONAL) true or false. Should the output be gzipped
# Returns:
#  None
###############################################################################
save_vtysh() {
    local vtysh_cmd=$1
    local filename=$2
    local do_gzip=${3:-false}

    if [[ ( "$NUM_ASICS" == 1 ) ]] ; then
        save_cmd "vtysh -c '${vtysh_cmd}'" "$filename" $do_gzip
    else
        for (( i=0; i<$NUM_ASICS; i++ ))
        do
            ns_cmd=$(get_vtysh_namespace $i)
            local cmd="vtysh $ns_cmd -c '${vtysh_cmd}'"
            local file=$filename.$i
            save_cmd "$cmd" "$file" "$do_gzip"
        done
    fi
}

###############################################################################
# Runs an ip command and saves its output to the incrementally built tar.
# Globals:
#  None
# Arguments:
#  cmd: the ip command to run sans 'ip'
#  filename: Files will be named 'ip.<filename>'
#  do_gzip: (OPTIONAL) true or false. Should the output be gzipped
# Returns:
#  None
###############################################################################
save_ip() {
    local ip_args=$1
    local filename="ip.$2"
    local do_gzip=${3:-false}
    save_cmd_all_ns "ip $ip_args" "$filename" "$do_gzip"
}

###############################################################################
# Runs a bridge command and saves its output to the incrementally built tar.
# Globals:
#  None
# Arguments:
#  cmd: the bridge command to run sans 'bridge'
#  filename: Files will be named 'bridge.<filename>'
#  do_gzip: (OPTIONAL) true or false. Should the output be gzipped
# Returns:
#  None
###############################################################################
save_bridge() {
    local br_args=$1
    local filename="bridge.$2"
    local do_gzip=${3:-false}
    save_cmd_all_ns "bridge $br_args" "$filename" $do_gzip
}

###############################################################################
# Dump the bridge L2 information
# Globals:
#  None
# Arguments:
#  None
# Returns:
#  None
###############################################################################
save_bridge_info() {
    save_bridge "fdb show" "fdb"
    save_bridge "vlan show" "vlan"
}

###############################################################################
# Iterates all neighbors and runs save_vtysh to save each neighbor's
# advertised-routes and received-routes
# On multi ASIC platform, collects information from all namespaces
# Globals:
#  None
# Arguments:
#  Optional arg namespace
# Returns:
#  None
###############################################################################
save_bgp_neighbor() {
    local timeout_cmd="timeout --foreground ${TIMEOUT_MIN}m"
    local asic_id=${1:-""}
    local ns=$(get_vtysh_namespace $asic_id)

    neighbor_list_v4=$(${timeout_cmd} vtysh $ns -c "show ip bgp neighbors" | grep "BGP neighbor is" | awk -F '[, ]' '{print $4}')
    for word in $neighbor_list_v4; do
        save_cmd "vtysh $ns -c \"show ip bgp neighbors $word advertised-routes\"" "ip.bgp.neighbor.$word.adv$asic_id"
        save_cmd "vtysh $ns -c \"show ip bgp neighbors $word routes\"" "ip.bgp.neighbor.$word.rcv$asic_id"
    done
    neighbor_list_v6=$(vtysh $ns -c "show bgp ipv6 neighbors" | grep "BGP neighbor is" | awk -F '[, ]' '{print $4}' | fgrep ':')
    for word in $neighbor_list_v6; do
        save_cmd "vtysh $ns -c \"show bgp ipv6 neighbors $word advertised-routes\"" "ipv6.bgp.neighbor.$word.adv$asic_id"
        save_cmd "vtysh $ns -c \"show bgp ipv6 neighbors $word routes\"" "ipv6.bgp.neighbor.$word.rcv$asic_id"
    done

    vrf_list=`${timeout_cmd} vtysh $ns -c "show vrf" | awk -F" " '{print $2}'`
    for vrf in $vrf_list; do
        neighbor_list=`${timeout_cmd} vtysh $ns -c "show ip bgp vrf $vrf neighbors" | grep "BGP neighbor is" | awk -F '[, ]' '{print $4}'`
        for word in $neighbor_list; do
            save_cmd "vtysh $ns -c \"show ip bgp vrf $vrf neighbors $word advertised-routes\"" "ip.bgp.neighbor.$vrf.$word.adv$asic_id"
            save_cmd "vtysh $ns -c \"show ip bgp vrf $vrf neighbors $word routes\"" "ip.bgp.neighbor.$vrf.$word.rcv$asic_id"
        done
    done
}

###############################################################################
# Iterates all ASIC namespaces on multi ASIC platform and on default (host)
# namespace on single ASIC platform
# Globals:
#  NUM_ASICS
# Arguments:
#  None
# Returns:
#  None
###############################################################################
save_bgp_neighbor_all_ns() {
    if [[ ( "$NUM_ASICS" == 1 ) ]] ; then
        save_bgp_neighbor
    else
        for (( i=0; i<$NUM_ASICS; i++ ))
        do
            save_bgp_neighbor $i
        done
    fi
}

###############################################################################
# Dump the nat config, iptables rules and conntrack nat entries
# Globals:
#  None
# Arguments:
#  None
# Returns:
#  None
###############################################################################
save_nat_info() {
    save_cmd_all_ns "iptables -t nat -nv -L" "nat.iptables"
    save_cmd_all_ns "conntrack -j -L" "nat.conntrack"
    save_cmd_all_ns "conntrack -j -L | wc" "nat.conntrackcount"
    save_cmd_all_ns "conntrack -L" "nat.conntrackall"
    save_cmd_all_ns "conntrack -L | wc" "nat.conntrackallcount"
    save_cmd_all_ns "show nat config" "nat.config"
}

###############################################################################
# Dump the BFD information from vtysh
# Globals:
#  None
# Arguments:
#  None
# Returns:
#  None
###############################################################################
save_bfd_info() {
    save_vtysh "show bfd peers" "frr.bfd.peers"
    save_vtysh "show bfd peers counters" "frr.bfd.peers.counters"
    save_vtysh "show bfd peers json" "frr.bfd.peers.json"
    save_vtysh "show bfd peers counters json" "frr.bfd.peers.counters.json"
}

###############################################################################
# Save IP related info
# Globals:
#  None
# Arguments:
#  None
# Returns:
#  None
###############################################################################
save_ip_info() {
    save_ip "link" "link"
    save_ip "addr" "addr"
    save_ip "rule" "rule"
    save_ip "route show table all" "route"
    save_ip "neigh" "neigh"
    save_ip "-s neigh show nud noarp" "neigh.noarp"
}

###############################################################################
# Save BGP related info
# Globals:
#  None
# Arguments:
#  None
# Returns:
#  None
###############################################################################
save_bgp_info() {
    save_vtysh "show ip bgp summary" "bgp.summary"
    save_vtysh "show ip bgp neighbors" "bgp.neighbors"
    save_vtysh "show ip bgp" "bgp.table"
    save_vtysh "show bgp ipv6 summary" "bgp.ipv6.summary"
    save_vtysh "show bgp ipv6 neighbors" "bgp.ipv6.neighbors"
    save_vtysh "show bgp ipv6" "bgp.ipv6.table"
    save_bgp_neighbor_all_ns
}

###############################################################################
# Save FRR related info
# Globals:
#  None
# Arguments:
#  None
# Returns:
#  None
###############################################################################
save_frr_info() {
    save_vtysh "show running-config" "frr.running_config"
    save_vtysh "show ip route vrf all" "frr.ip_route"
    save_vtysh "show ipv6 route vrf all" "frr.ip6_route"
    save_vtysh "show zebra fpm stats" "frr.fpm.stats"
    save_vtysh "show zebra dplane detailed" "frr.dplane"
    save_vtysh "show interface vrf all" "frr.interfaces"
    save_vtysh "show zebra client summary" "frr.client"
}

###############################################################################
# Save Redis DB contents
# Globals:
#  None
# Arguments:
#  None
# Returns:
#  None
###############################################################################
save_redis_info() {
    save_redis "APPL_DB"
    save_redis "ASIC_DB"
    save_redis "COUNTERS_DB"
    save_redis "CONFIG_DB"
    save_redis "FLEX_COUNTER_DB"
    save_redis "STATE_DB"
}

###############################################################################
# Given list of proc files, saves proc files to tar.
# Globals:
#  V
#  TARDIR
#  MKDIR
#  CP
#  DUMPDIR
#  TAR
#  RM
#  BASE
#  TARFILE
#  NOOP
# Arguments:
#  *procfiles: variable-length list of proc file paths to save
# Returns:
#  None
###############################################################################
save_proc() {
    local procfiles="$@"
    $MKDIR $V -p $TARDIR/proc
    for f in $procfiles
    do
        if $NOOP; then
            if [ -e $f ]; then
                echo "$CP $V -r $f $TARDIR/proc"
            fi
        else
            ( [ -e $f ] && $CP $V -r $f $TARDIR/proc ) || echo "$f not found" > $TARDIR/$f
        fi
    done
    $TAR $V -rhf $TARFILE -C $DUMPDIR --mode=+rw $BASE/proc
    $RM $V -rf $TARDIR/proc
}

###############################################################################
# Dumps all fields and values from given Redis DB.
# Arguments:
#  DB name: DB name
#  Filename: Destination filename, if not given then filename would be DB name
# Returns:
#  None
###############################################################################
save_redis() {
    local db_name=$1
    if [ $# -ge 2 ] && [ -n "$2" ]; then
        local dest_file_name=$2
    else
        local dest_file_name="$db_name"
    fi
    save_cmd_all_ns "sonic-db-dump -n '$db_name' -y" "$dest_file_name.json"
}

###############################################################################
# SAI DUMP from syncd
# Globals:
#  NUM_ASICS
# Arguments:
#  None
# Returns:
#  None
###############################################################################
save_saidump() {
    if [[ ( "$NUM_ASICS" == 1 ) ]] ; then
        save_cmd "docker exec -it syncd saidump" "saidump"
    else
        for (( i=0; i<$NUM_ASICS; i++ ))
        do
            save_cmd "docker exec -it syncd$i saidump" "saidump$i"
        done
    fi
}

###############################################################################
# Save platform related info
# Globals:
#  None
# Arguments:
#  None
# Returns:
#  None
###############################################################################
save_platform_info() {
    save_cmd "show platform syseeprom" "syseeprom"
    save_cmd "show platform psustatus" "psustatus"
    save_cmd "show platform ssdhealth" "ssdhealth"
    save_cmd "show platform temperature" "temperature"
    save_cmd "show platform fan" "fan"
}

###############################################################################
# Runs a comamnd and saves its output to the incrementally built tar.
# Globals:
#  LOGDIR
#  BASE
#  MKDIR
#  TAR
#  TARFILE
#  DUMPDIR
#  V
#  RM
#  NOOP
# Arguments:
#  filename: the full path of the file to save
#  base_dir: the directory in $TARDIR/ to stage the file
#  do_gzip: (OPTIONAL) true or false. Should the output be gzipped
# Returns:
#  None
###############################################################################
save_file() {
    local start_t=$(date +%s%3N)
    local end_t=0
    local orig_path=$1
    local supp_dir=$2
    local gz_path="$TARDIR/$supp_dir/$(basename $orig_path)"
    local tar_path="${BASE}/$supp_dir/$(basename $orig_path)"
    local do_gzip=${3:-true}
    local do_tar_append=${4:-true}
    [ ! -d "$TARDIR/$supp_dir" ] && $MKDIR $V -p "$TARDIR/$supp_dir"

    if $do_gzip; then
        gz_path="${gz_path}.gz"
        tar_path="${tar_path}.gz"
        if $NOOP; then
            echo "gzip -c $orig_path > $gz_path"
        else
            gzip -c $orig_path > $gz_path
        fi
    else
        if $NOOP; then
            echo "cp $orig_path $gz_path"
        else
            cp $orig_path $gz_path
        fi
    fi

    if $do_tar_append; then
        ($TAR $V -rhf $TARFILE -C $DUMPDIR "$tar_path" \
            || abort "${ERROR_PROCFS_SAVE_FAILED}" "tar append operation failed. Aborting to prevent data loss.") \
            && $RM $V -f "$gz_path"
    fi
    end_t=$(date +%s%3N)
    echo "[ save_file:$orig_path] : $(($end_t-$start_t)) msec"  >> $TECHSUPPORT_TIME_INFO
}

###############################################################################
# find_files routine
# Globals:
#  SINCE_DATE: list files only newer than given date
#  REFERENCE_FILE: the file to be created as a reference to compare modification time
# Arguments:
#  directory: directory to search files in
# Returns:
#  None
###############################################################################
find_files() {
    local -r directory=$1
    $TOUCH --date="${SINCE_DATE}" "${REFERENCE_FILE}"
    local -r find_command="find -L $directory -type f -newer ${REFERENCE_FILE}"

    echo $($find_command)
}

###############################################################################
# disable_logrotate routine
# Globals:
#  None
# Arguments:
#  None
# Returns:
#  None
###############################################################################
disable_logrotate() {
    sed -i '/\/usr\/sbin\/logrotate/s/^/#/g' /etc/cron.d/logrotate
}

###############################################################################
# enable_logrotate routine
# Globals:
#  None
# Arguments:
#  None
# Returns:
#  None
###############################################################################
enable_logrotate() {
    sed -i '/\/usr\/sbin\/logrotate/s/^#*//g' /etc/cron.d/logrotate
}


###############################################################################
# Collect Mellanox specific information
# Globals:
#  CMD_PREFIX
# Arguments:
#  None
# Returns:
#  None
###############################################################################
collect_mellanox() {
    local sai_dump_filename="/tmp/sai_sdk_dump_$(date +"%m_%d_%Y_%I_%M_%p")"
    ${CMD_PREFIX}docker exec -it syncd saisdkdump -f $sai_dump_filename
    ${CMD_PREFIX}docker exec syncd tar Ccf $(dirname $sai_dump_filename) - $(basename $sai_dump_filename) | tar Cxf /tmp/ -
    save_file $sai_dump_filename sai_sdk_dump true

    local mst_dump_filename="/tmp/mstdump"
    local max_dump_count="3"
    for i in $(seq 1 $max_dump_count); do
        ${CMD_PREFIX}/usr/bin/mstdump /dev/mst/mt*conf0 > "${mst_dump_filename}${i}"
        save_file "${mst_dump_filename}${i}" mstdump true
    done
}

###############################################################################
# Collect Broadcom specific information
# Globals:
#  None
# Arguments:
#  None
# Returns:
#  None
###############################################################################
collect_broadcom() {
    local platform=$(show platform summary --json | python -c 'import sys, json; \
        print(json.load(sys.stdin)["platform"])')
    local hwsku=$(show platform summary --json | python -c 'import sys, json; \
        print(json.load(sys.stdin)["hwsku"])')

    # save SAI configuration files (config.bcm, port_config.ini, sai.profile)
    if [ -d /usr/share/sonic/device/${platform}/${hwsku} ]; then
        # copy all the files in the HWSKU directory
        pushd /usr/share/sonic/device/${platform}/${hwsku} > /dev/null
        for file in $(find . -maxdepth 2 -type f); do
            save_file ${file} sai false
        done
        popd > /dev/null

        if [[ ("$NUM_ASICS" > 1) ]]; then
            for (( i=0; i<$NUM_ASICS; i++ ))
            do
                # config.bcm - copy the one with chip common properties merged
                for file in $(find /var/run/docker-syncd$i -type f -name "*.bcm"); do
                    save_file ${file} sai$i false
                done
                # sai.profile - copy the final sai.profile generated in docker-syncd
                if [ -f /var/run/docker-syncd$i/sai.profile ]; then
                    save_file /var/run/docker-syncd$i/sai.profile sai$i false
                fi
            done
        else
            # config.bcm - copy the one with chip common properties merged
            for file in $(find /var/run/docker-syncd -type f -name "*.bcm"); do
                save_file ${file} sai false
            done
            # sai.profile - copy the final sai.profile generated in docker-syncd
            if [ -f /var/run/docker-syncd/sai.profile ]; then
                save_file /var/run/docker-syncd/sai.profile sai false
            fi
        fi
    else
        echo "'/usr/share/sonic/device/${platform}/${hwsku}' does not exist" > /tmp/error
        save_file /tmp/error sai false
    fi

    save_cmd "cat /proc/bcm/knet/debug" "broadcom.knet.debug"
    save_cmd "cat /proc/bcm/knet/dma" "broadcom.knet.dma"
    save_cmd "cat /proc/bcm/knet/link" "broadcom.knet.link"
    save_cmd "cat /proc/bcm/knet/rate" "broadcom.knet.rate"

    save_bcmcmd_all_ns "-t5 version" "broadcom.version"
    save_bcmcmd_all_ns "-t5 soc" "broadcom.soc"
    save_bcmcmd_all_ns "-t5 ps" "broadcom.ps"
    save_bcmcmd_all_ns "\"l3 nat_ingress show\"" "broadcom.nat.ingress"
    save_bcmcmd_all_ns "\"l3 nat_egress show\"" "broadcom.nat.egress"
    save_bcmcmd_all_ns "\"ipmc table show\"" "broadcom.ipmc"
    save_bcmcmd_all_ns "\"multicast show\"" "broadcom.multicast"
    save_bcmcmd_all_ns "\"conf show\"" "conf.summary"
    save_bcmcmd_all_ns "\"fp show\"" "fp.summary"
    save_bcmcmd_all_ns "\"pvlan show\"" "pvlan.summary"
    save_bcmcmd_all_ns "\"l2 show\"" "l2.summary"
    save_bcmcmd_all_ns "\"l3 intf show\"" "l3.intf.summary"
    save_bcmcmd_all_ns "\"l3 defip show\"" "l3.defip.summary"
    save_bcmcmd_all_ns "\"l3 l3table show\"" "l3.l3table.summary"
    save_bcmcmd_all_ns "\"l3 egress show\"" "l3.egress.summary"
    save_bcmcmd_all_ns "\"l3 ecmp egress show\"" "l3.ecmp.egress.summary"
    save_bcmcmd_all_ns "\"l3 multipath show\"" "l3.multipath.summary"
    save_bcmcmd_all_ns "\"l3 ip6host show\"" "l3.ip6host.summary"
    save_bcmcmd_all_ns "\"l3 ip6route show\"" "l3.ip6route.summary"
    save_bcmcmd_all_ns "\"mc show\"" "multicast.summary"
    save_bcmcmd_all_ns "\"cstat *\"" "cstat.summary"
    save_bcmcmd_all_ns "\"mirror show\"" "mirror.summary"
    save_bcmcmd_all_ns "\"mirror dest show\"" "mirror.dest.summary"
    save_bcmcmd_all_ns "\"port *\"" "port.summary"
    save_bcmcmd_all_ns "\"d chg my_station_tcam\"" "mystation.tcam.summary"

    copy_from_masic_docker "syncd" "/var/log/diagrun.log" "/var/log/diagrun.log"
    copy_from_masic_docker "syncd" "/var/log/bcm_diag_post" "/var/log/bcm_diag_post"
}

###############################################################################
# Save log file
# Globals:
#  TAR, TARFILE, DUMPDIR, BASE, TARDIR, TECHSUPPORT_TIME_INFO
# Arguments:
#  None
# Returns:
#  None
###############################################################################
save_log_files() {
    disable_logrotate
    trap enable_logrotate HUP INT QUIT TERM KILL ABRT ALRM

    start_t=$(date +%s%3N)
    # gzip up all log files individually before placing them in the incremental tarball
    for file in $(find_files "/var/log/"); do
        # ignore the sparse file lastlog
        if [ "$file" = "/var/log/lastlog" ]; then
            continue
        fi
        # don't gzip already-gzipped log files :)
        # do not append the individual files to the main tarball
        if [ -z "${file##*.gz}" ]; then
            save_file $file log false false
        else
            save_file $file log true false
        fi
    done

    # Append the log folder to the main tarball
    ($TAR $V -rhf $TARFILE -C $DUMPDIR ${BASE}/log \
        || abort "${ERROR_TAR_FAILED}" "tar append operation failed. Aborting for safety") \
        && $RM $V -rf $TARDIR/log
    end_t=$(date +%s%3N)
    echo "[ TAR /var/log Files ] : $(($end_t-$start_t)) msec" >> $TECHSUPPORT_TIME_INFO

    enable_logrotate
}

###############################################################################
# Save warmboot files
# Globals:
#  TARDIR, TARFILE, TAR, DUMPDIR, TECHSUPPORT_TIME_INFO, NOOP
# Arguments:
#  None
# Returns:
#  None
###############################################################################
save_warmboot_files() {
    # Copy the warmboot files
    start_t=$(date +%s%3N)
    if $NOOP; then
        echo "$CP $V -rf /host/warmboot $TARDIR"
    else
        mkdir -p $TARDIR
        $CP $V -rf /host/warmboot $TARDIR

        ($TAR $V --warning=no-file-removed  -rhf $TARFILE -C $DUMPDIR --mode=+rw \
            $BASE/warmboot \
            || abort "${ERROR_TAR_FAILED}" "Tar append operation failed. Aborting for safety.") \
            && $RM $V -rf $TARDIR
    fi
    end_t=$(date +%s%3N)
    echo "[ Warm-boot Files ] : $(($end_t-$start_t)) msec" >> $TECHSUPPORT_TIME_INFO
}

###############################################################################
# Save crash files
# Globals:
#  None
# Arguments:
#  None
# Returns:
#  None
###############################################################################
save_crash_files() {
    # archive core dump files
    for file in $(find_files "/var/core/"); do
        # don't gzip already-gzipped log files :)
        if [ -z "${file##*.gz}" ]; then
            save_file $file core false
        else
            save_file $file core true
        fi
    done

    # archive kernel dump files
    [ -d /var/crash/ ] && for file in $(find_files "/var/crash/"); do
        # don't gzip already-gzipped dmesg files :)
        if [ ! ${file} = "/var/crash/kexec_cmd" -a ! ${file} = "/var/crash/export" ]; then
            if [[ ${file} == *"kdump."* ]]; then
                save_file $file kdump false
            else
                save_file $file kdump true
            fi
        fi
    done
}

###############################################################################
# Get number of ASICs in the platform
# Globals:
#  None
# Arguments:
#  None
# Returns:
#  ASIC Count
###############################################################################
get_asic_count() {
    local cmd="show platform summary --json | python -c 'import sys, json; \
               print(json.load(sys.stdin)[\"asic_count\"])'"
    echo `eval ${cmd} 2>&1`
}

###############################################################################
# Get counter snapshot
# Globals:
#  None
# Arguments:
#  asic_name: Name of the asic vendor
#  index: Index of counter snapshot
# Returns:
#  None
###############################################################################
save_counter_snapshot() {
    local asic_name="$1"
    local idx=$2
    counter_t=$(date +'%d/%m/%Y %H:%M:%S:%6N')

    save_cmd "echo $counter_t" "date.counter_$idx"
    save_cmd "show interface counters" "interface.counters_$idx"
    save_cmd_all_ns "show queue counters" "queue.counters_$idx"
    save_redis "COUNTERS_DB" "COUNTERS_DB_$idx"

    if [ "$asic_name" = "broadcom" ]; then
        save_cmd "cat /proc/bcm/knet/dstats" "broadcom.knet_drop.counters_$idx"
        save_cmd "cat /proc/bcm/knet/stats" "broadcom.knet_filter.counters_$idx"
        if [ -e /usr/local/bin/softnet_stat.sh ]; then
            save_cmd "softnet_stat.sh" "softnet_queue.counters_$idx"
        fi
        if [ -e /proc/bcm/knet/rx_drop ]; then
            save_cmd "cat /proc/bcm/knet/rx_drop" "broadcom.knet_queue.counters_$idx"
        fi
    fi
    save_cmd_all_ns "netstat -i" "netstat.counters_$idx"
    save_cmd_all_ns "ifconfig -a" "ifconfig.counters_$idx"
}

###############################################################################
# Main generate_dump routine
# Globals:
#  All of them.
# Arguments:
#  None
# Returns:
#  None
###############################################################################
main() {
    local start_t=0
    local end_t=0
    if [ `whoami` != root ] && ! $NOOP;
    then
        echo "$0: must be run as root (or in sudo)" >&2
        exit 10
    fi
    NUM_ASICS=$(get_asic_count)
    ${CMD_PREFIX}renice +5 -p $$ >> /dev/null
    ${CMD_PREFIX}ionice -c 2 -n 5 -p $$ >> /dev/null

    $MKDIR $V -p $TARDIR

    # Start with this script so its obvious what code is responsible
    $LN $V -s /usr/local/bin/generate_dump $TARDIR
    $TAR $V -chf $TARFILE -C $DUMPDIR $BASE
    $RM $V -f $TARDIR/sonic_dump

    # Start populating timing data
    echo $BASE > $TECHSUPPORT_TIME_INFO
    start_t=$(date +%s%3N)

    # Capture /proc state early
    save_proc /proc/buddyinfo /proc/cmdline /proc/consoles \
        /proc/cpuinfo /proc/devices /proc/diskstats /proc/dma \
        /proc/interrupts /proc/iomem /proc/ioports /proc/kallsyms \
        /proc/loadavg /proc/locks /proc/meminfo /proc/misc \
        /proc/modules /proc/self/mounts /proc/self/net \
        /proc/pagetypeinfo /proc/partitions /proc/sched_debug /proc/slabinfo \
        /proc/softirqs /proc/stat /proc/swaps /proc/sysvipc /proc/timer_list \
        /proc/uptime /proc/version /proc/vmallocinfo /proc/vmstat \
        /proc/zoneinfo \
        || abort "${ERROR_PROCFS_SAVE_FAILED}" "Proc saving operation failed. Aborting for safety."
    end_t=$(date +%s%3N)
    echo "[ Capture Proc State ] : $(($end_t-$start_t)) msec" >> $TECHSUPPORT_TIME_INFO

    # Save all the processes within each docker
    save_cmd "show services" services.summary

    # Save reboot cause information
    save_cmd "show reboot-cause" reboot.cause

    local asic="$(/usr/local/bin/sonic-cfggen -y /etc/sonic/sonic_version.yml -v asic_type)"
    # 1st counter snapshot early. Need 2 snapshots to make sense of counters trend.
    save_counter_snapshot $asic 1

    save_cmd "systemd-analyze blame" "systemd.analyze.blame"
    save_cmd "systemd-analyze dump" "systemd.analyze.dump"
    save_cmd "systemd-analyze plot" "systemd.analyze.plot.svg"

    save_platform_info

    save_cmd "show vlan brief" "vlan.summary"
    save_cmd "show version" "version"
    save_cmd "show platform summary" "platform.summary"
    save_cmd "cat /host/machine.conf" "machine.conf"
    save_cmd "docker stats --no-stream" "docker.stats"

    save_cmd "sensors" "sensors"
    save_cmd "lspci -vvv -xx" "lspci"
    save_cmd "lsusb -v" "lsusb"
    save_cmd "sysctl -a" "sysctl"

    save_ip_info
    save_bridge_info

    save_frr_info
    save_bgp_info

    save_cmd "show interface status -d all" "interface.status"
    save_cmd "show interface transceiver presence" "interface.xcvrs.presence"
    save_cmd "show interface transceiver eeprom --dom" "interface.xcvrs.eeprom"
    save_cmd "show ip interface -d all" "ip.interface"

    save_cmd "lldpctl" "lldpctl"
    if [[ ( "$NUM_ASICS" > 1 ) ]]; then
        for (( i=0; i<$NUM_ASICS; i++ ))
        do
            save_cmd "docker exec -it lldp$i lldpcli show statistics" "lldp$i.statistics"
            save_cmd "docker logs bgp$i" "docker.bgp$i.log"
            save_cmd "docker logs swss$i" "docker.swss$i.log"
        done
    else
        save_cmd "docker exec -it lldp lldpcli show statistics" "lldp.statistics"
        save_cmd "docker logs bgp" "docker.bgp.log"
        save_cmd "docker logs swss" "docker.swss.log"
    fi

    save_cmd "ps aux" "ps.aux"
    save_cmd "top -b -n 1" "top"
    save_cmd "free" "free"
    save_cmd "vmstat 1 5" "vmstat"
    save_cmd "vmstat -m" "vmstat.m"
    save_cmd "vmstat -s" "vmstat.s"
    save_cmd "mount" "mount"
    save_cmd "df" "df"
    save_cmd "dmesg" "dmesg"

    save_nat_info
    save_bfd_info
    save_redis_info

    save_cmd "docker ps -a" "docker.ps"
    save_cmd "docker top pmon" "docker.pmon"

    local -r dump_plugins="$(find ${PLUGINS_DIR} -type f -executable)"
    for plugin in $dump_plugins; do
        # save stdout output of plugin and gzip it
        save_cmd "$plugin" "$(basename $plugin)" true false
    done

    save_saidump

    if [[ "$asic" = "mellanox" ]]; then
        collect_mellanox
    fi

    if [ "$asic" = "broadcom" ]; then
        collect_broadcom
    fi

    # 2nd counter snapshot late. Need 2 snapshots to make sense of counters trend.
    save_counter_snapshot $asic 2

    $RM $V -rf $TARDIR
    $MKDIR $V -p $TARDIR
    $MKDIR $V -p $LOGDIR
    # Copying the /etc files to a directory and then tar it
    $CP -r /etc $TARDIR/etc
    rm_list=$(find -L $TARDIR/etc -maxdepth 5 -type l)
    if [ ! -z "$rm_list" ]
    then
        rm $rm_list
    fi

    start_t=$(date +%s%3N)
    ($TAR $V --warning=no-file-removed -rhf $TARFILE -C $DUMPDIR --mode=+rw \
        --exclude="etc/alternatives" \
        --exclude="*/etc/passwd*" \
        --exclude="*/etc/shadow*" \
        --exclude="*/etc/group*" \
        --exclude="*/etc/gshadow*" \
        --exclude="*/etc/ssh*" \
        --exclude="*get_creds*" \
        --exclude="*snmpd.conf*" \
        --exclude="/etc/mlnx" \
        --exclude="/etc/mft" \
        $BASE/etc \
        || abort "${ERROR_TAR_FAILED}" "Tar append operation failed. Aborting for safety.") \
        && $RM $V -rf $TARDIR
    end_t=$(date +%s%3N)
    echo "[ TAR /etc Files ] : $(($end_t-$start_t)) msec" >> $TECHSUPPORT_TIME_INFO

    save_log_files
    save_warmboot_files
    save_crash_files

    # run 'hw-management-generate-dump.sh' script and save the result file
    HW_DUMP_FILE=/usr/bin/hw-management-generate-dump.sh
    if [ -f "$HW_DUMP_FILE" ]; then
      /usr/bin/hw-management-generate-dump.sh $ALLOW_PROCESS_STOP
      save_file "/tmp/hw-mgmt-dump*" "hw-mgmt" false
      rm -f /tmp/hw-mgmt-dump*
    else
      echo "HW Mgmt dump script $HW_DUMP_FILE does not exist"
    fi
    # Save techsupport timing profile info
    save_file $TECHSUPPORT_TIME_INFO log false

    # clean up working tar dir before compressing
    $RM $V -rf $TARDIR

    if $DO_COMPRESS; then
        $GZIP $V $TARFILE
        if [ $? -eq 0 ]; then
            TARFILE="${TARFILE}.gz"
        else
            echo "WARNING: gzip operation appears to have failed." >&2
        fi
    fi

    echo ${TARFILE}
}

###############################################################################
# Terminates generate_dump early just in case we have issues.
# Globals:
#  None
# Arguments:
#  retcode: 0-255 return code to exit with. default is 1
#  msg: (OPTIONAL) msg to print to standard error
# Returns:
#  None
###############################################################################
abort() {
    local exitcode=${1:-1}
    local msg=${2:-Error. Terminating early for safety.}
    echo "$msg" >&2
    exit $exitcode
}

###############################################################################
# Prints usage to stdout.
# Globals:
#  None
# Arguments:
#  None
# Returns:
#  None
###############################################################################
usage() {
    cat <<EOF
$0 [-xnvh]

Create a SONiC system dump for support/debugging. Requires root privileges.

OPTIONS
    -x
        Enable bash debug mode.
    -h
        The usage information you are reading right now
    -v
        Enable verbose mode. All commands (like tar, mkdir, rm..) will have -v
        passed to them
    -n
        Noop mode. Don't actually create anything, just echo what would happen
    -a
        Allow any process stop. This allows for collection of platform HW register
        status, which may require potential system interruption
    -z
        Don't compress the tar at the end.
    -s DATE
        Collect logs since DATE;
        The argument is a mostly free format human readable string such as
        "24 March", "yesterday", etc.
    -t TIMEOUT_MINS
        Command level timeout in minutes

EOF
}

while getopts ":xnvhzas:t:" opt; do
    case $opt in
        x)
            # enable bash debugging
            PS4="+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }"
            set -x
            ;;
        h)
            usage
            exit 0
            ;;
        v)
            # echo commands about to be run to stderr
            set -v
            V="-v"
            ;;
        n)
            TAR="echo tar"
            MKDIR="echo mkdir"
            RM="echo rm"
            LN="echo ln"
            GZIP="echo gzip"
            CMD_PREFIX="echo "
            MV="echo mv"
            CP="echo cp"
            TOUCH="echo touch"
            NOOP=true
            ;;
        z)
            DO_COMPRESS=false
            ;;
        a)
            ALLOW_PROCESS_STOP="-a"
            ;;
        s)
            SINCE_DATE="${OPTARG}"
            # validate date expression
            date --date="${SINCE_DATE}" &> /dev/null || abort "${ERROR_INVALID_ARGUMENT}" "Invalid date expression passed: '${SINCE_DATE}'"
            ;;
        t)
            TIMEOUT_MIN="${OPTARG}"
            ;;
        /?)
            echo "Invalid option: -$OPTARG" >&2
            exit 1
            ;;
    esac
done

main
